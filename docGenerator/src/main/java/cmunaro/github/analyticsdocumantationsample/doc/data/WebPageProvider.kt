package cmunaro.github.analyticsdocumantationsample.doc.data

import cmunaro.github.analyticsdocumantationsample.doc.domain.model.EventRepresentation
import cmunaro.github.analyticsdocumantationsample.doc.domain.model.ParameterRepresentation
import kotlinx.html.BODY
import kotlinx.html.HTML
import kotlinx.html.TD
import kotlinx.html.b
import kotlinx.html.body
import kotlinx.html.dd
import kotlinx.html.dl
import kotlinx.html.dt
import kotlinx.html.h2
import kotlinx.html.head
import kotlinx.html.html
import kotlinx.html.stream.createHTML
import kotlinx.html.style
import kotlinx.html.table
import kotlinx.html.tbody
import kotlinx.html.td
import kotlinx.html.th
import kotlinx.html.thead
import kotlinx.html.title
import kotlinx.html.tr

internal interface WebPageProvider {
    fun createEventDocumentationPage(events: List<EventRepresentation>): String
}

internal class WebPageProviderImpl(
    private val webPageStyleDataSource: WebPageStyleDataSource = WebPageStyleDataSourceImpl()
) : WebPageProvider {
    override fun createEventDocumentationPage(
        events: List<EventRepresentation>
    ): String {
        return createHTML().html {
            pageHead()
            pageBody(events)
        }
    }

    private fun HTML.pageHead() {
        head {
            style { +webPageStyleDataSource.style }
            title(PAGE_TITLE)
        }
    }

    private fun HTML.pageBody(events: List<EventRepresentation>) {
        body {
            h2 { +LONG_PAGE_TITLE }
            eventsTable(events)
        }
    }

    private fun BODY.eventsTable(events: List<EventRepresentation>) {
        table {
            thead {
                tr {
                    th { +CLASS_NAME_HEADER }
                    th { +EVENT_NAME_HEADER }
                    th { +DESCRIPTION_HEADER }
                    th { +PARAMETERS_HEADER }
                    th { +ANDROID_HEADER }
                    th { +IOS_HEADER }
                }
            }
            tbody {
                events
                    .forEach { event ->
                        tr {
                            td { +event.className }
                            td { b { +event.eventName } }
                            td { +event.description }
                            td {
                                event.parameters
                                    .sortedBy(ParameterRepresentation::parameterName)
                                    .forEach { parameter ->
                                        dl {
                                            dt {
                                                +parameter.parameterName
                                            }
                                            dd { +parameter.description }
                                        }
                                    }
                            }
                            td { implementation(event.eventImplementation.implementedByAndroid) }
                            td { implementation(event.eventImplementation.implementedByIOS) }
                        }
                    }
            }
        }
    }

    private fun TD.implementation(state: Boolean) {
        if (state) +"YES" else +"NO"
    }

    companion object {
        private const val PAGE_TITLE = "Analytics events"
        private const val LONG_PAGE_TITLE = "Autogenerated analytics events"
        private const val CLASS_NAME_HEADER = "Class name"
        private const val EVENT_NAME_HEADER = "Event name"
        private const val DESCRIPTION_HEADER = "Description"
        private const val PARAMETERS_HEADER = "Parameters"
        private const val ANDROID_HEADER = "Android"
        private const val IOS_HEADER = "iOS"
    }
}
